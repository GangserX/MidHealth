// ------------------------------------------------------------------
// PatientCredential.compact
// ------------------------------------------------------------------
// Privacy-preserving healthcare attestation contract for Midnight.
//
// PUBLIC (on-chain):  credentialHash, issuerPubKey, credentialState,
//                     attestationCount (Counter)
//
// PRIVATE (off-chain): patient identity, raw credential payload,
//                      issuer secret key — accessed only via witnesses.
//
// Circuits:
//   issueCredential  – doctor stores a hashed credential on-chain
//   proveVaccinated  – patient proves they hold a valid credential
//   revokeCredential – issuer can mark a credential as revoked
//
// Reference: https://docs.midnight.network/develop/reference/compact/lang-ref
// Pattern:   https://github.com/midnightntwrk/example-bboard (bboard.compact)
// ------------------------------------------------------------------

pragma language_version 0.21;

import CompactStandardLibrary;

// ---- Types -------------------------------------------------------

export enum CredentialState {
  EMPTY,
  ACTIVE,
  REVOKED
}

export enum VerificationResult {
  NONE,
  VALID,
  INVALID
}

// ---- Public ledger state -----------------------------------------
// These fields are visible on-chain to anyone inspecting the contract.

export ledger credentialState: CredentialState;

// Hash of (patientId ++ credentialPayload ++ issuerPubKey)
export ledger credentialHash: Bytes<32>;

// Public key derived from the issuer's secret key (never leaked)
export ledger issuerPubKey: Bytes<32>;

// Monotonic counter — incremented on every state-changing operation
export ledger attestationCount: Counter;

// Result of the most recent verification attempt
export ledger lastVerification: VerificationResult;

// Sequence number used in key derivation to prevent replay
export ledger sequence: Counter;

// ---- Constructor -------------------------------------------------

constructor() {
  credentialState = CredentialState.EMPTY;
  credentialHash  = pad(32, "");
  issuerPubKey    = pad(32, "");
  lastVerification = VerificationResult.NONE;
  sequence.increment(1);
}

// ---- Witnesses (private inputs from TypeScript) ------------------
// These run OFF-CHAIN on the user's local machine.
// DANGER: Do not trust witness results blindly — any DApp can
//         supply any implementation. Verify constraints in-circuit.
// Ref: https://docs.midnight.network/develop/reference/compact/lang-ref

witness issuerSecretKey(): Bytes<32>;

witness patientSecretId(): Bytes<32>;

witness credentialPayload(): Bytes<32>;

// ---- Helper circuits (not exported — internal only) ---------------

// Derive a public key from a secret key + sequence (replay-safe).
// Mirrors the pattern used in the bboard example.
// Src: https://github.com/midnightntwrk/example-bboard
circuit derivePublicKey(sk: Bytes<32>, seq: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<3, Bytes<32>>>(
    [pad(32, "midhealth:pk:"), seq, sk]
  );
}

// Hash the credential triple for on-chain storage.
circuit hashCredential(
  patientId:  Bytes<32>,
  payload:    Bytes<32>,
  issuerPub:  Bytes<32>
): Bytes<32> {
  return persistentHash<Vector<3, Bytes<32>>>(
    [patientId, payload, issuerPub]
  );
}

// ---- Exported circuits (entry points for transactions) -----------

// ISSUE: Doctor (issuer) stores a hashed credential on-chain.
// - Witness supplies issuerSecretKey, patientSecretId, credentialPayload
// - Only hashes & the derived public key are disclosed
// - Raw patient data NEVER touches the chain
export circuit issueCredential(): [] {
  assert(
    credentialState == CredentialState.EMPTY,
    "Credential slot is already occupied"
  );

  // Derive issuer public key from the secret key + sequence
  const seqBytes = sequence as Field as Bytes<32>;
  const isk      = issuerSecretKey();
  const pubKey   = derivePublicKey(isk, seqBytes);

  // Compute credential hash from private inputs
  const pid     = patientSecretId();
  const payload = credentialPayload();
  const cHash   = hashCredential(pid, payload, pubKey);

  // Write public state — only hashes; raw data stays local
  issuerPubKey    = disclose(pubKey);
  credentialHash  = disclose(cHash);
  credentialState = CredentialState.ACTIVE;
  attestationCount.increment(1);
}

// PROVE: Patient proves they hold a valid credential matching the
//        on-chain hash, WITHOUT revealing identity or raw data.
//        The ZK proof is generated locally by the proof server.
export circuit proveVaccinated(): [] {
  assert(
    credentialState == CredentialState.ACTIVE,
    "No active credential to verify"
  );

  // Patient provides their private credential components via witnesses
  const pid     = patientSecretId();
  const payload = credentialPayload();

  // Recompute the hash using the patient's private inputs + the public issuerPubKey
  const computedHash = hashCredential(pid, payload, issuerPubKey);

  // The ZK circuit asserts the computed hash matches the on-chain hash.
  // If the patient has the correct data, the proof succeeds.
  // If not, the assertion fails and the proof cannot be generated.
  assert(
    computedHash == credentialHash,
    "Credential proof failed: private data does not match on-chain hash"
  );

  lastVerification = VerificationResult.VALID;
  attestationCount.increment(1);
}

// REVOKE: Only the original issuer can revoke the credential.
//         Proves ownership via the same secret key derivation.
export circuit revokeCredential(): [] {
  assert(
    credentialState == CredentialState.ACTIVE,
    "No active credential to revoke"
  );

  const seqBytes = sequence as Field as Bytes<32>;
  const isk      = issuerSecretKey();
  const pubKey   = derivePublicKey(isk, seqBytes);

  // Only the original issuer (matching public key) can revoke
  assert(
    issuerPubKey == pubKey,
    "Only the original issuer can revoke this credential"
  );

  credentialState  = CredentialState.REVOKED;
  lastVerification = VerificationResult.NONE;
  sequence.increment(1);
  attestationCount.increment(1);
}
